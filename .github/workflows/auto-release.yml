name: Automated Release from Branch

on:
  push:
    branches: [ 'release/v*' ]
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - '.github/workflows/validate-action.yml'

permissions:
  contents: write
  packages: write

jobs:
  determine-version:
    runs-on: ubuntu-latest
    name: Determine Release Version
    outputs:
      version: ${{ steps.version.outputs.version }}
      major: ${{ steps.version.outputs.major }}
      minor: ${{ steps.version.outputs.minor }}
      patch: ${{ steps.version.outputs.patch }}
      full-tag: ${{ steps.version.outputs.full-tag }}
      should-release: ${{ steps.version.outputs.should-release }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0  # Need full history for version determination
          
      - name: Extract branch version and determine next version
        id: version
        run: |
          BRANCH_NAME="${{ github.ref_name }}"
          echo "Branch: $BRANCH_NAME"
          
          # Extract major version from branch name (e.g., release/v1 -> 1)
          MAJOR_VERSION=$(echo "$BRANCH_NAME" | sed 's/release\/v//')
          echo "Major version: $MAJOR_VERSION"
          
          # Get the latest tag for this major version
          LATEST_TAG=$(git tag -l "v${MAJOR_VERSION}.*.*" | sort -V | tail -n1)
          echo "Latest tag for v${MAJOR_VERSION}: $LATEST_TAG"
          
          if [ -z "$LATEST_TAG" ]; then
            # No previous releases for this major version, start with x.0.0
            NEW_VERSION="${MAJOR_VERSION}.0.0"
            echo "No previous releases, starting with $NEW_VERSION"
          else
            # Parse the latest tag to increment patch version
            CURRENT_VERSION=$(echo "$LATEST_TAG" | sed 's/v//')
            CURRENT_MAJOR=$(echo "$CURRENT_VERSION" | cut -d. -f1)
            CURRENT_MINOR=$(echo "$CURRENT_VERSION" | cut -d. -f2)
            CURRENT_PATCH=$(echo "$CURRENT_VERSION" | cut -d. -f3)
            
            # Check if we need to increment based on commits since last tag
            COMMITS_SINCE_TAG=$(git rev-list ${LATEST_TAG}..HEAD --count)
            echo "Commits since $LATEST_TAG: $COMMITS_SINCE_TAG"
            
            if [ "$COMMITS_SINCE_TAG" -eq 0 ]; then
              echo "No new commits since last tag, no release needed"
              echo "should-release=false" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            # Increment patch version
            NEW_PATCH=$((CURRENT_PATCH + 1))
            NEW_VERSION="${CURRENT_MAJOR}.${CURRENT_MINOR}.${NEW_PATCH}"
            echo "Incrementing to $NEW_VERSION"
          fi
          
          # Output version components
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "major=$MAJOR_VERSION" >> $GITHUB_OUTPUT
          echo "minor=$(echo "$NEW_VERSION" | cut -d. -f1-2)" >> $GITHUB_OUTPUT
          echo "patch=$(echo "$NEW_VERSION" | cut -d. -f3)" >> $GITHUB_OUTPUT
          echo "full-tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "should-release=true" >> $GITHUB_OUTPUT
          
          echo "Will create release: v$NEW_VERSION"

  update-action-and-tag:
    needs: determine-version
    if: needs.determine-version.outputs.should-release == 'true'
    runs-on: ubuntu-latest
    name: Update Action and Create Tag
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Update action.yml to pin version
        run: |
          VERSION="${{ needs.determine-version.outputs.version }}"
          echo "Updating action.yml to use version: $VERSION"
          
          # Update the Docker image reference
          sed -i "s|docker://ghcr.io/vlindersoftware/validate-coverage:[^'\"]*|docker://ghcr.io/vlindersoftware/validate-coverage:$VERSION|g" action.yml
          
          # Verify the change
          if grep -q "docker://ghcr.io/vlindersoftware/validate-coverage:$VERSION" action.yml; then
            echo "‚úÖ Successfully updated action.yml"
            cat action.yml | grep -A2 -B2 "image:"
          else
            echo "‚ùå Failed to update action.yml"
            exit 1
          fi
          
      - name: Commit action.yml update and create tags
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Commit the action.yml update
          git add action.yml
          git commit -m "chore: Update action.yml to reference ${{ needs.determine-version.outputs.version }}"
          
          # Now create tags on this commit (which includes the updated action.yml)
          FULL_TAG="${{ needs.determine-version.outputs.full-tag }}"
          VERSION="${{ needs.determine-version.outputs.version }}"
          MAJOR="v${{ needs.determine-version.outputs.major }}"
          MINOR="v${{ needs.determine-version.outputs.minor }}"
          
          echo "Creating tags: $FULL_TAG, $MINOR, $MAJOR"
          
          # Create the full version tag on the current commit
          git tag "$FULL_TAG" -m "Release $FULL_TAG"
          
          # Delete and recreate convenience tags (these will point to remote)
          git tag -d "$MAJOR" 2>/dev/null || true
          git push origin ":refs/tags/$MAJOR" 2>/dev/null || true
          git tag -d "$MINOR" 2>/dev/null || true  
          git push origin ":refs/tags/$MINOR" 2>/dev/null || true
          
          # Create convenience tags on current commit
          git tag "$MAJOR" -m "Latest $MAJOR release: $FULL_TAG"
          git tag "$MINOR" -m "Latest $MINOR release: $FULL_TAG"
          
          # Push the commit first, then the tags
          git push
          git push origin "$FULL_TAG"
          git push origin "$MAJOR"
          git push origin "$MINOR"
          
          echo "‚úÖ Created and pushed tags successfully"
          echo "üéØ All tags point to commit with updated action.yml"

  build-and-release:
    needs: [determine-version, update-action-and-tag]
    if: needs.determine-version.outputs.should-release == 'true'
    name: Build Docker and Create GitHub Release
    uses: ./.github/workflows/release-tags.yml
    permissions:
      contents: write
      packages: write
    secrets: inherit
    
  notify-completion:
    needs: [determine-version, build-and-release]
    if: always() && needs.determine-version.outputs.should-release == 'true'
    runs-on: ubuntu-latest
    name: Notify Release Completion
    
    steps:
      - name: Release Summary
        run: |
          VERSION="${{ needs.determine-version.outputs.version }}"
          FULL_TAG="${{ needs.determine-version.outputs.full-tag }}"
          
          if [ "${{ needs.build-and-release.result }}" = "success" ]; then
            echo "üéâ Release $FULL_TAG completed successfully!"
            echo ""
            echo "‚úÖ Docker image published: ghcr.io/vlindersoftware/validate-coverage:$VERSION"
            echo "‚úÖ GitHub release created: https://github.com/VlinderSoftware/validate-coverage/releases/tag/$FULL_TAG"
            echo "‚úÖ Action can now be used as:"
            echo "   - uses: vlindersoftware/validate-coverage@$FULL_TAG"
            echo "   - uses: vlindersoftware/validate-coverage@v${{ needs.determine-version.outputs.major }}"
            echo "   - uses: vlindersoftware/validate-coverage@v${{ needs.determine-version.outputs.minor }}"
          else
            echo "‚ùå Release $FULL_TAG failed!"
            echo "Check the workflow logs for details."
            exit 1
          fi